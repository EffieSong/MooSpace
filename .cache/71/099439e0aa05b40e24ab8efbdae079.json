{"id":"shader/fragmentShader.glsl","dependencies":[{"name":"/Users/SYF/Documents/GitHub/MooSpace/package.json","includedInParent":true,"mtime":1614846984000}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nvarying vec2 vUv;\\nuniform float uTime;\\nuniform float uColMix;\\nuniform float uFrequency;\\nvec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\\n    return a + b * cos(6.28318 * (c * t + d));\\n}\\n\\nvec2 random2(vec2 st) {\\n    st = vec2(dot(st, vec2(97.1, 311.7)),\\n        dot(st, vec2(69.5, 183.3)));\\n\\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\\n}\\n\\nfloat noise(vec2 st) {\\n    vec2 i = floor(st);\\n    vec2 f = fract(st);\\n\\n    vec2 u = f * f * (3.0 - 2.0 * f);\\n\\n    return mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\\n            dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\\n        mix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\\n            dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\\n}\\n\\nfloat stroke(float x, float s, float strokeWidth) {\\n    return step(s - strokeWidth * .5, x) - step(s + strokeWidth * .5, x);\\n}\\nfloat circleSDF(vec2 st) {\\n    return length(st - 0.5) * 2.; // map (-0.5,0.5) to (-1,1)\\n}\\n\\nfloat noiseCircleSDF(vec2 st, float radius, float edgeSmooth, float offset) {\\n    float a = atan(st.y, st.x);\\n    float r = radius;\\n    r += sin(a * 2.) * 0.12 * noise(st*.7 + offset);\\n    return 1. - smoothstep(r, r + edgeSmooth, circleSDF(st));\\n}\\nfloat noiseShape(vec2 st, float radius,float edgeSmooth,float intensity,float offset) {\\n\\tst = vec2(0.5)-st;\\n    float r = length(st)*2.0;\\n    float a = atan(st.y,st.x);\\n    float m = abs(mod(a+uTime*2.,3.14*2.)-3.14)/2.864;\\n    float f = radius;\\n    m += noise(st+uTime*0.1)*.5;\\n    // a *= 1.+abs(atan(uTime*0.2))*.1;\\n    // a *= 1.+noise(st+uTime*0.1)*0.1;\\n     f += sin(a*1.)*noise(st+uTime*0.9+offset)*.2;\\n    f += sin(a*3.)*noise(st+uTime*1.9*intensity+offset)*.2*intensity;\\n    f += sin(a*1.)*noise(st+uTime*2.2*intensity+offset)*0.9*intensity;\\n    return smoothstep(f,f+edgeSmooth,r);\\n}\\nvoid main() {\\n    vec3 bg = vec3(0.,0.,0.);\\n    vec3 col  =vec3(0.0, 0.0, 0.0);\\n\\n    vec3 col_joy1 = vec3(0.9882, 0.6078, 0.8275);\\n    vec3 col_joy2 = vec3(0.9882, 0.8431, 0.4431);\\n\\n    vec3 col_sad1  =vec3(0.0667, 0.1882, 0.4118);\\n    vec3 col_sad2  =vec3(0.2745, 0.1412, 0.3137);\\n    \\n    vec3 col_angry1  =vec3(0.0863, 0.0588, 0.0);\\n    vec3 col_angry2  =vec3(0.7137, 0.1255, 0.0235);\\n    vec3 col1;\\n    vec3 col2;\\n    float frequence;\\n\\n   if(uColMix>0.1){    \\n     col1  =mix(col_sad1,col_joy1,(uColMix-0.1)/0.9);\\n     col2  =mix(col_sad2,col_joy2,(uColMix-0.1)/0.9);\\n      frequence = 0.2;\\n    }else{\\n     col1  =mix(col_angry1,col_sad1,uColMix);\\n     col2  =mix(col_angry2,col_sad2,uColMix);\\n     frequence = 0.9;\\n    }\\n\\n  //  vec3 bg = mix(vec3(0.1529, 0.1529, 0.1529),vec3(0.7137, 0.6902, 0.5647),vUv.y);\\n\\n   col = mix(col1,col2, noiseShape(vUv,0.1,0.4,frequence,1.));\\n\\n   \\n  gl_FragColor = mix(vec4(0.), vec4(col,1.0), 1.0-noiseShape(vUv,0.25,0.4,frequence,0.));\\n\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"shader/fragmentShader.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"shader/fragmentShader.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"shader/fragmentShader.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"shader/fragmentShader.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"shader/fragmentShader.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":2926},"source":"shader/fragmentShader.glsl","original":{"line":1,"column":0}}],"sources":{"shader/fragmentShader.glsl":"module.exports=\"#define GLSLIFY 1\\nvarying vec2 vUv;\\nuniform float uTime;\\nuniform float uColMix;\\nuniform float uFrequency;\\nvec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\\n    return a + b * cos(6.28318 * (c * t + d));\\n}\\n\\nvec2 random2(vec2 st) {\\n    st = vec2(dot(st, vec2(97.1, 311.7)),\\n        dot(st, vec2(69.5, 183.3)));\\n\\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\\n}\\n\\nfloat noise(vec2 st) {\\n    vec2 i = floor(st);\\n    vec2 f = fract(st);\\n\\n    vec2 u = f * f * (3.0 - 2.0 * f);\\n\\n    return mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\\n            dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\\n        mix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\\n            dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\\n}\\n\\nfloat stroke(float x, float s, float strokeWidth) {\\n    return step(s - strokeWidth * .5, x) - step(s + strokeWidth * .5, x);\\n}\\nfloat circleSDF(vec2 st) {\\n    return length(st - 0.5) * 2.; // map (-0.5,0.5) to (-1,1)\\n}\\n\\nfloat noiseCircleSDF(vec2 st, float radius, float edgeSmooth, float offset) {\\n    float a = atan(st.y, st.x);\\n    float r = radius;\\n    r += sin(a * 2.) * 0.12 * noise(st*.7 + offset);\\n    return 1. - smoothstep(r, r + edgeSmooth, circleSDF(st));\\n}\\nfloat noiseShape(vec2 st, float radius,float edgeSmooth,float intensity,float offset) {\\n\\tst = vec2(0.5)-st;\\n    float r = length(st)*2.0;\\n    float a = atan(st.y,st.x);\\n    float m = abs(mod(a+uTime*2.,3.14*2.)-3.14)/2.864;\\n    float f = radius;\\n    m += noise(st+uTime*0.1)*.5;\\n    // a *= 1.+abs(atan(uTime*0.2))*.1;\\n    // a *= 1.+noise(st+uTime*0.1)*0.1;\\n     f += sin(a*1.)*noise(st+uTime*0.9+offset)*.2;\\n    f += sin(a*3.)*noise(st+uTime*1.9*intensity+offset)*.2*intensity;\\n    f += sin(a*1.)*noise(st+uTime*2.2*intensity+offset)*0.9*intensity;\\n    return smoothstep(f,f+edgeSmooth,r);\\n}\\nvoid main() {\\n    vec3 bg = vec3(0.,0.,0.);\\n    vec3 col  =vec3(0.0, 0.0, 0.0);\\n\\n    vec3 col_joy1 = vec3(0.9882, 0.6078, 0.8275);\\n    vec3 col_joy2 = vec3(0.9882, 0.8431, 0.4431);\\n\\n    vec3 col_sad1  =vec3(0.0667, 0.1882, 0.4118);\\n    vec3 col_sad2  =vec3(0.2745, 0.1412, 0.3137);\\n    \\n    vec3 col_angry1  =vec3(0.0863, 0.0588, 0.0);\\n    vec3 col_angry2  =vec3(0.7137, 0.1255, 0.0235);\\n    vec3 col1;\\n    vec3 col2;\\n    float frequence;\\n\\n   if(uColMix>0.1){    \\n     col1  =mix(col_sad1,col_joy1,(uColMix-0.1)/0.9);\\n     col2  =mix(col_sad2,col_joy2,(uColMix-0.1)/0.9);\\n      frequence = 0.2;\\n    }else{\\n     col1  =mix(col_angry1,col_sad1,uColMix);\\n     col2  =mix(col_angry2,col_sad2,uColMix);\\n     frequence = 0.9;\\n    }\\n\\n  //  vec3 bg = mix(vec3(0.1529, 0.1529, 0.1529),vec3(0.7137, 0.6902, 0.5647),vUv.y);\\n\\n   col = mix(col1,col2, noiseShape(vUv,0.1,0.4,frequence,1.));\\n\\n   \\n  gl_FragColor = mix(vec4(0.), vec4(col,1.0), 1.0-noiseShape(vUv,0.25,0.4,frequence,0.));\\n\\n}\";"},"lineCount":null}},"error":null,"hash":"41ac2d0b9d6f89c8bbfec567b0a372a4","cacheData":{"env":{}}}